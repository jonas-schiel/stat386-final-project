### Demonstration of the Functions:

```{python}
#| echo: False
import pandas as pd
import requests
from bs4 import BeautifulSoup
import seaborn as sns
import matplotlib.pyplot as plt

# Done Already
def wrangle_data(filepath, value_col, drop_rows=None, rename_from=None):
    df = pd.read_csv(filepath)
    
    if drop_rows is not None:
        df = df.drop(drop_rows)
    
    df['Year'] = df['observation_date'].str.extract(r'(\d{4})')
    df['Month'] = df['observation_date'].str.extract(r'((?<=\d{4}-)\d{2})')
    
    if rename_from is not None:
        df[value_col] = df[rename_from]
        df = df.drop(rename_from, axis=1)
    
    df = df.drop('observation_date', axis=1)
    
    df['Month'] = df['Month'].astype(int)
    df['Month'] = pd.to_datetime(df['Month'], format='%m').dt.month_name()
    df['Year'] = df['Year'].astype(int)
    
    column_order = ['Month', 'Year', value_col]
    df = df[column_order]
    
    return df

# Done Already
def merge_and_sort_data(df1, df2, df3):
    combined = pd.merge(df1, df2, on=['Month', 'Year'], how='outer')
    
    data = pd.merge(combined, df3, on=['Year', 'Month'], how='outer')
    
    month_order = [
        "January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
    ]
    data["Month"] = pd.Categorical(data["Month"], categories=month_order, ordered=True)
    
    data = data.sort_values(["Year", "Month"]).reset_index(drop=True)
    
    return data


# Done Already
def add_presidents_to_data(data, html_text, min_year=1948):

    tables = pd.read_html(html_text)
    df = tables[0]

    df["No."] = df["No.[a]"]
    df["President"] = df["Name (birth–death)"].str.extract(
        r"([A-Z][a-z]+\W[A-Z][a-z]+)"
    )
    df["Party"] = df["Party[b][17].1"]

    df[["Start", "End"]] = df["Term[16]"].str.split("–", expand=True)
    df["Start_Month"] = df["Start"].str.extract(r"([A-Z][a-z]+)")
    df["Start_Year"] = df["Start"].str.extract(r"(\d{4})")
    df["End_Month"] = df["End"].str.extract(r"([A-Z][a-z]+)")
    df["End_Year"] = df["End"].str.extract(r"(\d{4})")

    df["End_Year"] = df["End_Year"].fillna(2025)
    df.loc[df["End_Month"] == "Incumbent", "End_Month"] = "November"

    df["Start_Date"] = pd.to_datetime(
        df["Start_Month"] + " " + df["Start_Year"].astype(str)
    )
    df["End_Date"] = pd.to_datetime(
        df["End_Month"] + " " + df["End_Year"].astype(str)
    )

    rows = []
    for _, row in df.iterrows():
        dates = pd.date_range(row["Start_Date"], row["End_Date"], freq="MS")
        for d in dates:
            rows.append({
                "Year": d.year,
                "Month": d.month_name(),
                "President": row["President"],
                "Party": row["Party"],
            })

    Presidents = pd.DataFrame(rows)
    Presidents = Presidents[Presidents["Year"] >= min_year]

    Final = pd.merge(data, Presidents, on=["Year", "Month"], how="outer")

    Final["Month"] = Final["Month"].str.strip()
    Final["President"] = Final["President"].str.strip()

    month_map = {
        "January": 1, "February": 2, "March": 3, "April": 4,
        "May": 5, "June": 6, "July": 7, "August": 8,
        "September": 9, "October": 10, "November": 11, "December": 12
    }

    terms = [
        ("Harry S Truman", (1945, "April"), (1953, "January")),
        ("Dwight D Eisenhower", (1953, "January"), (1961, "January")),
        ("John F Kennedy", (1961, "January"), (1963, "November")),
        ("Lyndon B Johnson", (1963, "November"), (1969, "January")),
    ]

    for i, row in Final.iterrows():
        if pd.isna(row["President"]):
            current = (row["Year"], month_map[row["Month"]])

            for pres, (sy, sm), (ey, em) in terms:
                start = (sy, month_map[sm])
                end = (ey, month_map[em])

                if start <= current < end:
                    Final.loc[i, "President"] = pres
                    break

    month_order = list(month_map.keys())
    Final["Month"] = pd.Categorical(
        Final["Month"], categories=month_order, ordered=True
    )

    Final = Final.sort_values(["Year", "Month"]).reset_index(drop=True)
    Final = Final.drop_duplicates()
    Final["GDP"] = Final["GDP"].interpolate(method="linear") \
                           .ffill()
    Final = Final.iloc[:-2]

    return Final

# Done Already
def get_presidents_html(ua, email, url="https://en.wikipedia.org/wiki/List_of_presidents_of_the_United_States"):
    r = requests.get(url, headers={"User-Agent": ua, "From": email}, timeout=15)
    r.raise_for_status()  
    return r.text

GDP = wrangle_data(
    filepath='GDP.csv',
    value_col='GDP',
    drop_rows=[0, 1, 2, 3]
)

CPI = wrangle_data(
    filepath='CPI.csv',
    value_col='CPI',
    drop_rows=range(12),
    rename_from='CPIAUCSL'
)

url = 'https://en.wikipedia.org/wiki/List_of_presidents_of_the_United_States' 
email = "skirk03@byu.edu" 
ua = f"STAT386-class-scraper/1.0 (+{email})" 
r = requests.get(url, headers={"User-Agent": ua, "From": email}, timeout=15)
my_email = "skirk03@byu.edu"

def simple_eda(df, scatter_points=False):
    
    vote_cols = [col for col in df.columns if "Percentage" in col]
    for col in vote_cols:
        df[col] = df[col].astype(str).str.rstrip("%").astype(float)
    
    econ_cols = ["CPI", "UNRATE", "GDP"]
    
    econ_cols = [col for col in econ_cols if col in df.columns]
    
    colors = ["red", "blue"]
    fig, axes = plt.subplots(1, len(econ_cols), figsize=(5 * len(econ_cols), 5), sharey=True)
    
    if len(econ_cols) == 1:
        axes = [axes]
    
    for i, indicator in enumerate(econ_cols):
        ax = axes[i]
        for j, col in enumerate(vote_cols):
            sns.regplot(
                x=indicator,
                y=col,
                data=df,
                ax=ax,
                scatter=scatter_points,
                line_kws={"linewidth": 2, "color": colors[j % len(colors)]},
                ci=None
            )
        ax.set_title(f"{indicator} vs Vote Share", fontsize=12, fontweight='bold')
        ax.set_xlabel(f"{indicator} Value", fontsize=10)
        if i == 0:
            ax.set_ylabel("Vote Percentage (%)", fontsize=10)
        ax.grid(True)
    
    handles = [plt.Line2D([0], [0], color=colors[j % len(colors)], lw=2) for j, col in enumerate(vote_cols)]
    labels = [col.replace(" Percentage", "") for col in vote_cols]
    fig.legend(handles, labels, loc="upper right", fontsize=10)
    fig.suptitle("Trend Lines Between Economic Conditions and Vote Share", fontsize=14, fontweight='bold', y=1.05)
    plt.tight_layout()
    plt.show()
    
    numeric_cols = df.select_dtypes(include='number').columns.tolist()
    plt.figure(figsize=(8, 6))
    sns.heatmap(df[numeric_cols].corr(), annot=True, cmap="coolwarm", fmt=".2f")
    plt.title("Correlation Heatmap")
    plt.show()

df = pd.read_csv('economic_election_data.csv')
df = df.drop('Unnamed: 0', axis = 1)

def economic_trends_for_president(df, president, indicators, term = 'both'):
    if indicators is None:
        indicators = ['GDP', 'CPI', 'UNRATE']

    president_data = df[df['President Elect'] == president].copy()
    president_data = president_data.drop_duplicates(subset=['Year', 'Month'])

    if term != 'both':
        years = sorted(president_data['Year'].unique())

        if term == 'first':
            first_term_years = years[:4]
            president_data = president_data[president_data['Year'].isin(first_term_years)]
        elif term == 'second':
            second_term_years = years[4:8]
            president_data = president_data[president_data['Year'].isin(second_term_years)]

    columns = ['Year', 'Month'] + indicators
    return president_data[columns]

def simple_eda(df, election_years_only=False):
    df_clean = df.copy()
    df_clean = df_clean[df_clean['Year'] % 4 == 0]
    
    
    vote_cols = [col for col in df_clean.columns if "Percentage" in col]
    for col in vote_cols:
        df_clean[col] = df_clean[col].astype(str).str.rstrip("%").astype(float)
    
    econ_cols = ["CPI", "UNRATE", "GDP"]
    econ_cols = [col for col in econ_cols if col in df_clean.columns]
    
    numeric_cols = df_clean.select_dtypes(include='number').columns.tolist()
    correlation_matrix = df_clean[numeric_cols].corr()
    
    return {
        'regression_data': df_clean[econ_cols + vote_cols],
        'correlation_matrix': correlation_matrix,
        'vote_cols': vote_cols,
        'econ_cols': econ_cols
    }

def president_party_and_economic_analyis(df, president):
    president_data = df[df['President Elect'] == president].copy()

    if len(president_data) == 0:
        return None
    
    econ_data = president_data.drop_duplicates(subset=['Year', 'Month']).sort_values(['Year', 'Month'])
    first = econ_data.iloc[0]
    last = econ_data.iloc[-1]

    start_y = first['Year']
    last_y = last['Year']
    years_in_office = last_y - start_y + 1

    all_changes = {
        'start_year': first['Year'],
        'end_year': last['Year'],
        'years_in_office': years_in_office,
        'GDP_change': last['GDP'] - first['GDP'],
        'CPI_change': last['CPI'] - first['CPI'],
        'UNRATE_change': last['UNRATE'] - first['UNRATE']
    }

    year_change = econ_data['Year'].max()
    year_change_data = econ_data[econ_data['Year'] == year_change].sort_values('Month')

    if len(year_change_data) >= 2:
        last_year_start = year_change_data.iloc[0]
        last_year_end = year_change_data.iloc[-1]
    
        last_year_changes = {
            'year': year_change,
            'GDP_change': last_year_end['GDP'] - last_year_start['GDP'],
            'CPI_change': last_year_end['CPI'] - last_year_start['CPI'],
            'UNRATE_change': last_year_end['UNRATE'] - last_year_start['UNRATE']
        }
    else:
        last_year_changes = None

    election_cycle = president_data['Election Cycle'].max()
    next_cycle = election_cycle + 4

    current_party = president_data['Winning Party'].iloc[0]
    current_election = president_data[president_data['Election Cycle'] == election_cycle][
        ['State', 'Republican Percentage', 'Democratic Percentage']
    ].drop_duplicates()

    next_election = df[df['Election Cycle'] == next_cycle]
    
    if len(next_election) > 0:
        vote_swings = current_election.merge(
            next_election, 
            on='State', 
            suffixes=('_current', '_next')
        )

        vote_swings['Republican Percentage_current'] = vote_swings['Republican Percentage_current'].astype(str).str.rstrip('%').astype(float)
        vote_swings['Republican Percentage_next'] = vote_swings['Republican Percentage_next'].astype(str).str.rstrip('%').astype(float)
        vote_swings['Democratic Percentage_current'] = vote_swings['Democratic Percentage_current'].astype(str).str.rstrip('%').astype(float)
        vote_swings['Democratic Percentage_next'] = vote_swings['Democratic Percentage_next'].astype(str).str.rstrip('%').astype(float)

        vote_swings['Republican_swing'] = vote_swings['Republican Percentage_next'] - vote_swings['Republican Percentage_current']
        vote_swings['Democratic_swing'] = vote_swings['Democratic Percentage_next'] - vote_swings['Democratic Percentage_current'] 
        
        vote_swings_unique = vote_swings[['State', 'Republican_swing', 'Democratic_swing']].drop_duplicates()
        state_swings = vote_swings_unique[['State', 'Republican_swing', 'Democratic_swing']].to_dict('records')
    else:
        state_swings = None

    if len(next_election) > 0:
        next_party = next_election['Winning Party'].iloc[0]
        next_president = next_election['President Elect'].iloc[0]
        if (current_party != next_party):
            party_switched = True
        else:
            party_switched = False
    else:
        next_party = None
        next_president = None
        party_switched = None
    
    party_transition = {
        'current_party': current_party,
        'following_president': next_president,
        'next_party': next_party,
        'party_switched': party_switched
    }
    
    return {
        'president': president,
        'overall_economic_changes': all_changes,
        'last_year_changes': last_year_changes,
        'state_vote_swings': state_swings,
        'party_transition': party_transition
    }

```


This function, wrangle_data, allows us to wrangle downloadable csvs about economic data. Here we plug in our unemployment rate dataset and it does all of the wrangling and formatting for us. Here are just the first five rows of what the data will look like afterwards.
```{python}
UNRATE = wrangle_data(
    filepath='UNRATE.csv',
    value_col='UNRATE'
)

UNRATE.head()
```

The next function, merge_and_sort_data, combines all of the economic data that we gathered into one data set. Here you can see that all three of the data sets are combined together to make one dataset. There are a few missing values but those get taken care of in another function that we have.
```{python}
combined_data = merge_and_sort_data(UNRATE, GDP, CPI)
combined_data.head()
```

Our next fuction, get_presidents_html, allows us to scrape the data about presidents of the United States, the years that they were president and the political party that they represented. This allows for easier data combination and cleaning so we will combine that with the last function, add_presidnets_to_data, we combine the data that we have and clean it creating our final president and economic dataset ready to be combined with the election data.
```{python}
url = 'https://en.wikipedia.org/wiki/List_of_presidents_of_the_United_States' 
email = "skirk03@byu.edu" 
ua = f"STAT386-class-scraper/1.0 (+{email})" 
r = requests.get(url, headers={"User-Agent": ua, "From": email}, timeout=15)

text = get_presidents_html(ua = f"STAT386-class-scraper/1.0 (+{email})", email = "skirk03@byu.edu")

Final_df = add_presidents_to_data(combined_data, text)
Final_df.head(20)
```

Another function we have allows for some basic eda and creates a correlation matrix for the factors that are used in our dataset and how they influence each other.
```{python}
simple_eda(df, election_years_only=False)
```

This econimic_trends_for_president function allows users to select a president of their choice and see the economic impact that took place during their presidency. There is an option to select just one of the specified economic evaluators or just two of them or even all three. Users can also filter based on the term that the president was serving in at the time.
```{python}
economic_trends_for_president(df, "Donald Trump", indicators = None)
```

```{python}
president_party_and_economic_analyis(df, "Donald Trump")
```